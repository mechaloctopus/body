<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Poly Muscle Highlighter</title>
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #f0f0f0; display: flex; height: 100vh; overflow: hidden; }
        #container { flex-grow: 1; position: relative; }
        #canvas { display: block; }
        #controls {
            width: 280px; /* Slightly wider for better text */
            padding: 20px;
            background-color: #fff;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box; /* Include padding in height/width */
        }
        #controls h2 { margin-top: 0; }
        #controls label {
            display: block;
            margin-bottom: 10px;
            padding: 5px; /* Add padding for easier clicking */
            border-radius: 3px; /* Slightly rounded corners */
            cursor: pointer;
            user-select: none; /* Prevent text selection on double click */
            transition: background-color 0.2s ease; /* Smooth feedback */
        }
         #controls input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle; /* Align checkbox better */
            pointer-events: none; /* Prevent direct interaction with checkbox */
         }
         .state-off { color: #555; background-color: #f9f9f9; }
         .state-off:hover { background-color: #eee; }
         .state-selected { color: red; font-weight: bold; background-color: #ffe0e0; }
         .state-completed { color: purple; font-weight: bold; /*text-decoration: line-through;*/ background-color: #f0e0f0; } /* Removed strikethrough for better indeterminate look */

    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="controls">
        <h2>Muscle Groups</h2>
        <label data-muscle="pectorals">
            <input type="checkbox" id="cb-pectorals"> Pectorals (Chest)
        </label>
        <label data-muscle="deltoids">
            <input type="checkbox" id="cb-deltoids"> Deltoids (Shoulders)
        </label>
        <label data-muscle="biceps">
            <input type="checkbox" id="cb-biceps"> Biceps
        </label>
        <label data-muscle="triceps">
            <input type="checkbox" id="cb-triceps"> Triceps
        </label>
        <label data-muscle="forearms">
            <input type="checkbox" id="cb-forearms"> Forearms
        </label>
        <label data-muscle="abs">
            <input type="checkbox" id="cb-abs"> Abdominals (Abs)
        </label>
        <label data-muscle="obliques">
            <input type="checkbox" id="cb-obliques"> Obliques (Sides)
        </label>
        <label data-muscle="back_upper">
            <input type="checkbox" id="cb-back_upper"> Upper Back (Traps, Rhomboids)
        </label>
        <label data-muscle="back_lats">
            <input type="checkbox" id="cb-back_lats"> Lats (Mid Back)
        </label>
        <label data-muscle="back_lower">
            <input type="checkbox" id="cb-back_lower"> Lower Back (Erectors)
        </label>
        <label data-muscle="glutes">
            <input type="checkbox" id="cb-glutes"> Glutes
        </label>
        <label data-muscle="quads">
            <input type="checkbox" id="cb-quads"> Quadriceps (Quads)
        </label>
        <label data-muscle="hamstrings">
            <input type="checkbox" id="cb-hamstrings"> Hamstrings
        </label>
         <label data-muscle="calves">
            <input type="checkbox" id="cb-calves"> Calves
        </label>
        <hr>
        <p><strong>Instructions:</strong><br>
        - Click + Drag to rotate.<br>
        - Scroll to zoom.<br>
        - Click muscle names to cycle: Off -> Selected (Red) -> Completed (Purple) -> Off.
        </p>
    </div>

    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let humanGroup; // Group to hold all parts of the human
        const muscleMeshes = {}; // Store references to muscle meshes
        const muscleStates = {}; // Store state: 'off', 'selected', 'completed'

        const colors = {
            skin: 0xd3a18d,
            muscleOff: 0xaaaaaa,
            muscleSelected: 0xff0000,
            muscleCompleted: 0x800080,
            muscleOpacity: 0.85
        };

        const muscleMaterials = {
            off: new THREE.MeshStandardMaterial({
                color: colors.muscleOff, transparent: true, opacity: 0, visible: false,
                roughness: 0.8, metalness: 0.1
            }),
            selected: new THREE.MeshStandardMaterial({
                color: colors.muscleSelected, transparent: true, opacity: colors.muscleOpacity,
                roughness: 0.6, metalness: 0.1, emissive: 0x330000
            }),
            completed: new THREE.MeshStandardMaterial({
                color: colors.muscleCompleted, transparent: true, opacity: colors.muscleOpacity,
                roughness: 0.6, metalness: 0.1, emissive: 0x1a001a
            })
        };

        // --- Initialization ---
        function init() {
            const container = document.getElementById('container');
            const canvas = document.getElementById('canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 6);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(8, 15, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0);
            controls.minDistance = 2;
            controls.maxDistance = 15;
            controls.update();

            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 1, metalness: 0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0; // Adjust ground based on final model base
            ground.receiveShadow = true;
            scene.add(ground);

            buildHumanModel();
            setupUI();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- Build Model (REVISED HIERARCHY) ---
        function buildHumanModel() {
            humanGroup = new THREE.Group();
            scene.add(humanGroup);

             // Set ground position based on lowest expected point (e.g., bottom of lower leg)
             const lowestPointY = -0.7; // Approximate based on leg lengths below
             scene.getObjectByName('groundPlane').position.y = lowestPointY;


            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: colors.skin,
                roughness: 0.8,
                metalness: 0.05
            });

            // --- Helper Functions ---
            function createBodyPart(geometry, material) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                return mesh;
            }

            function createMusclePart(geometry, muscleName) {
                 const mesh = new THREE.Mesh(geometry, muscleMaterials.off.clone());
                 mesh.visible = false;
                 const key = muscleName;
                 if (!muscleMeshes[key]) {
                     muscleMeshes[key] = [];
                 }
                 muscleMeshes[key].push(mesh);
                 return mesh;
            }

            // --- Dimensions ---
            const torsoHeight = 1.0;
            const torsoWidth = 0.7;
            const torsoDepth = 0.35;
            const shoulderOffsetY = torsoHeight / 2 - 0.1; // Y offset from torso center
            const shoulderOffsetX = torsoWidth / 2;        // X offset for shoulder placement
            const hipOffsetY = -torsoHeight / 2;          // Y offset for hip placement
            const hipOffsetX = torsoWidth / 4;            // X offset for hip placement
            const armLengthUpper = 0.6;
            const armLengthLower = 0.55;
            const legLengthUpper = 0.8;
            const legLengthLower = 0.7;
            const neckHeight = 0.15;
            const headRadius = 0.25;
            const muscleOffset = 0.01;

            // --- Torso, Neck, Head (Base of Hierarchy) ---
            const torsoGeo = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth);
            const torso = createBodyPart(torsoGeo, bodyMaterial);
            torso.position.y = legLengthUpper + legLengthLower + torsoHeight / 2 + lowestPointY; // Position torso relative to ground
            humanGroup.add(torso);

            const neckGeo = new THREE.CylinderGeometry(0.1, 0.12, neckHeight, 8);
            const neck = createBodyPart(neckGeo, bodyMaterial);
            neck.position.y = torsoHeight / 2 + neckHeight / 2; // Local to torso center
            torso.add(neck); // Child of torso

            const headGeo = new THREE.SphereGeometry(headRadius, 12, 8);
            const head = createBodyPart(headGeo, bodyMaterial);
            head.position.y = neckHeight / 2 + headRadius; // Local to neck center
            neck.add(head); // Child of neck


            // --- Arms ---
            const armAngleZ = Math.PI / 16; // A-Pose angle
            const elbowAngleX = Math.PI / 12; // Elbow bend

            // -- Left Arm --
            const upperArmL = new THREE.Group(); // Group to act as shoulder joint
            upperArmL.position.set(-shoulderOffsetX, shoulderOffsetY, 0); // Position joint relative to torso center
            upperArmL.rotation.z = armAngleZ; // Rotate the whole arm group
            torso.add(upperArmL);

            const upperArmLGeo = new THREE.CylinderGeometry(0.1, 0.08, armLengthUpper, 8);
            upperArmLGeo.translate(0, -armLengthUpper / 2, 0); // Pivot at the top (shoulder)
            const upperArmLMesh = createBodyPart(upperArmLGeo, bodyMaterial);
            upperArmL.add(upperArmLMesh); // Add mesh to the joint group

            const lowerArmL = new THREE.Group(); // Group for elbow joint
            lowerArmL.position.y = -armLengthUpper; // Position elbow at the end of upper arm (local)
            lowerArmL.rotation.x = elbowAngleX; // Apply elbow bend locally
            upperArmL.add(lowerArmL); // Child of upper arm group

            const lowerArmLGeo = new THREE.CylinderGeometry(0.08, 0.06, armLengthLower, 8);
            lowerArmLGeo.translate(0, -armLengthLower / 2, 0); // Pivot at the top (elbow)
            const lowerArmLMesh = createBodyPart(lowerArmLGeo, bodyMaterial);
            lowerArmL.add(lowerArmLMesh);

            // -- Right Arm -- (Similar structure)
            const upperArmR = new THREE.Group();
            upperArmR.position.set(shoulderOffsetX, shoulderOffsetY, 0);
            upperArmR.rotation.z = -armAngleZ; // Opposite rotation
            torso.add(upperArmR);

            const upperArmRGeo = new THREE.CylinderGeometry(0.1, 0.08, armLengthUpper, 8);
            upperArmRGeo.translate(0, -armLengthUpper / 2, 0);
            const upperArmRMesh = createBodyPart(upperArmRGeo, bodyMaterial);
            upperArmR.add(upperArmRMesh);

            const lowerArmR = new THREE.Group();
            lowerArmR.position.y = -armLengthUpper;
            lowerArmR.rotation.x = elbowAngleX;
            upperArmR.add(lowerArmR);

            const lowerArmRGeo = new THREE.CylinderGeometry(0.08, 0.06, armLengthLower, 8);
            lowerArmRGeo.translate(0, -armLengthLower / 2, 0);
            const lowerArmRMesh = createBodyPart(lowerArmRGeo, bodyMaterial);
            lowerArmR.add(lowerArmRMesh);


            // --- Legs ---
            const kneeAngleX = -Math.PI / 18; // Knee bend

            // -- Left Leg --
            const upperLegL = new THREE.Group(); // Hip joint
            upperLegL.position.set(-hipOffsetX, hipOffsetY, 0); // Position relative to torso center
            torso.add(upperLegL);

            const upperLegLGeo = new THREE.CylinderGeometry(0.15, 0.12, legLengthUpper, 8);
            upperLegLGeo.translate(0, -legLengthUpper / 2, 0); // Pivot at the top (hip)
            const upperLegLMesh = createBodyPart(upperLegLGeo, bodyMaterial);
            upperLegL.add(upperLegLMesh);

            const lowerLegL = new THREE.Group(); // Knee joint
            lowerLegL.position.y = -legLengthUpper; // Position knee at end of upper leg
            lowerLegL.rotation.x = kneeAngleX; // Apply knee bend
            upperLegL.add(lowerLegL); // Child of upper leg group

            const lowerLegLGeo = new THREE.CylinderGeometry(0.12, 0.08, legLengthLower, 8);
            lowerLegLGeo.translate(0, -legLengthLower / 2, 0); // Pivot at the top (knee)
            const lowerLegLMesh = createBodyPart(lowerLegLGeo, bodyMaterial);
            lowerLegL.add(lowerLegLMesh);

            // -- Right Leg -- (Similar structure)
            const upperLegR = new THREE.Group();
            upperLegR.position.set(hipOffsetX, hipOffsetY, 0);
            torso.add(upperLegR);

            const upperLegRGeo = new THREE.CylinderGeometry(0.15, 0.12, legLengthUpper, 8);
            upperLegRGeo.translate(0, -legLengthUpper / 2, 0);
            const upperLegRMesh = createBodyPart(upperLegRGeo, bodyMaterial);
            upperLegR.add(upperLegRMesh);

            const lowerLegR = new THREE.Group();
            lowerLegR.position.y = -legLengthUpper;
            lowerLegR.rotation.x = kneeAngleX;
            upperLegR.add(lowerLegR);

            const lowerLegRGeo = new THREE.CylinderGeometry(0.12, 0.08, legLengthLower, 8);
            lowerLegRGeo.translate(0, -legLengthLower / 2, 0);
            const lowerLegRMesh = createBodyPart(lowerLegRGeo, bodyMaterial);
            lowerLegR.add(lowerLegRMesh);


            // --- Muscle Groups (Attached to correct body part groups) ---

            // Pectorals (Child of Torso)
            const pecWidth = 0.3; const pecHeight = 0.3; const pecDepth = 0.08;
            const pecGeo = new THREE.BoxGeometry(pecWidth, pecHeight, pecDepth);
            const pecL = createMusclePart(pecGeo, 'pectorals');
            pecL.position.set(-pecWidth/2 - 0.02, 0.1, torsoDepth / 2 + muscleOffset); // Local to Torso center
            pecL.rotation.y = -Math.PI / 20;
            torso.add(pecL);
            const pecR = createMusclePart(pecGeo, 'pectorals');
            pecR.position.set( pecWidth/2 + 0.02, 0.1, torsoDepth / 2 + muscleOffset); // Local to Torso center
            pecR.rotation.y = Math.PI / 20;
            torso.add(pecR);

            // Deltoids (Child of Upper Arm Groups)
            const deltRadius = 0.18;
            const deltGeo = new THREE.SphereGeometry(deltRadius, 8, 6, 0, Math.PI * 2, 0, Math.PI / 1.8);
            const deltL = createMusclePart(deltGeo, 'deltoids');
            deltL.position.set(0, 0.05, 0); // Local to shoulder joint (upperArmL group origin)
            // Rotation might need minor adjustment relative to arm pivot
            upperArmL.add(deltL); // Child of upperArmL group
            const deltR = createMusclePart(deltGeo.clone().rotateY(Math.PI), 'deltoids');
            deltR.position.set(0, 0.05, 0); // Local to shoulder joint (upperArmR group origin)
            upperArmR.add(deltR); // Child of upperArmR group

            // Biceps (Child of Upper Arm Groups)
            const bicepGeo = new THREE.CapsuleGeometry(0.06, 0.2, 4, 8);
            const bicepL = createMusclePart(bicepGeo, 'biceps');
            bicepL.position.set(0, -armLengthUpper*0.4, 0.08); // Position relative to shoulder joint, slightly forward
            bicepL.rotation.x = Math.PI / 2; // Orient capsule
            upperArmL.add(bicepL);
            const bicepR = createMusclePart(bicepGeo, 'biceps');
            bicepR.position.set(0, -armLengthUpper*0.4, 0.08); // Position relative to shoulder joint
            bicepR.rotation.x = Math.PI / 2;
            upperArmR.add(bicepR);

            // Triceps (Child of Upper Arm Groups)
            const tricepGeo = new THREE.CapsuleGeometry(0.07, 0.25, 4, 8);
            const tricepL = createMusclePart(tricepGeo, 'triceps');
            tricepL.position.set(0, -armLengthUpper*0.45, -0.08); // Position relative to shoulder, slightly back
            tricepL.rotation.x = Math.PI / 2;
            upperArmL.add(tricepL);
            const tricepR = createMusclePart(tricepGeo, 'triceps');
            tricepR.position.set(0, -armLengthUpper*0.45, -0.08); // Position relative to shoulder
            tricepR.rotation.x = Math.PI / 2;
            upperArmR.add(tricepR);

            // Forearms (Child of Lower Arm Groups)
            const forearmGeo = new THREE.CapsuleGeometry(0.07, 0.3, 4, 8);
            const forearmL = createMusclePart(forearmGeo, 'forearms');
            forearmL.position.set(0, -armLengthLower*0.3, 0.04); // Position relative to elbow joint
            forearmL.rotation.x = Math.PI / 2; // Orient capsule
            lowerArmL.add(forearmL); // CHILD OF LOWER ARM
            const forearmR = createMusclePart(forearmGeo, 'forearms');
            forearmR.position.set(0, -armLengthLower*0.3, 0.04); // Position relative to elbow joint
            forearmR.rotation.x = Math.PI / 2;
            lowerArmR.add(forearmR); // CHILD OF LOWER ARM

            // Abdominals (Child of Torso)
            const absWidth = 0.35; const absHeight = 0.45; const absDepth = 0.08;
            const absGeo = new THREE.BoxGeometry(absWidth, absHeight, absDepth);
            const abs = createMusclePart(absGeo, 'abs');
            abs.position.set(0, -0.1, torsoDepth / 2 + muscleOffset); // Local to torso center
            torso.add(abs);

            // Obliques (Child of Torso)
            const obqWidth = 0.1; const obqHeight = 0.4; const obqDepth = 0.25;
            const obqGeo = new THREE.BoxGeometry(obqWidth, obqHeight, obqDepth);
            const obqL = createMusclePart(obqGeo, 'obliques');
            obqL.position.set(-(torsoWidth/2 - 0.02), -0.1, 0); // Local to torso center, at the side
            // obqL.rotation.y = Math.PI/10; // Less necessary now? Adjust if needed.
            torso.add(obqL);
            const obqR = createMusclePart(obqGeo, 'obliques');
            obqR.position.set( (torsoWidth/2 - 0.02), -0.1, 0); // Local to torso center, at the side
            // obqR.rotation.y = -Math.PI/10;
            torso.add(obqR);

            // Back - Upper (Traps) (Child of Torso)
            const trapWidth = 0.4; const trapHeight = 0.4; const trapDepth = 0.1;
            const trapGeo = new THREE.BoxGeometry(trapWidth, trapHeight, trapDepth);
            const backUpper = createMusclePart(trapGeo, 'back_upper');
            backUpper.position.set(0, shoulderOffsetY - trapHeight/2, -torsoDepth / 2 - muscleOffset); // Local to torso
            torso.add(backUpper);

            // Back - Lats (Child of Torso)
            const latWidth = 0.25; const latHeight = 0.5; const latDepth = 0.1;
            const latGeo = new THREE.BoxGeometry(latWidth, latHeight, latDepth);
            const latL = createMusclePart(latGeo, 'back_lats');
            latL.position.set(-(torsoWidth/2 - latWidth/2 + 0.05), -0.1, -torsoDepth / 2 - muscleOffset * 2); // Local to torso
            latL.rotation.y = Math.PI/12; // Slight angle
            torso.add(latL);
            const latR = createMusclePart(latGeo, 'back_lats');
            latR.position.set( (torsoWidth/2 - latWidth/2 + 0.05), -0.1, -torsoDepth / 2 - muscleOffset * 2); // Local to torso
            latR.rotation.y = -Math.PI/12; // Slight angle
            torso.add(latR);

            // Back - Lower (Erectors) (Child of Torso)
            const lowBackWidth = 0.2; const lowBackHeight = 0.3; const lowBackDepth = 0.08;
            const backLowerGeo = new THREE.BoxGeometry(lowBackWidth, lowBackHeight, lowBackDepth);
            const backLower = createMusclePart(backLowerGeo, 'back_lower');
            backLower.position.set(0, hipOffsetY + lowBackHeight/2 + 0.1, -torsoDepth / 2 - muscleOffset); // Local to torso
            torso.add(backLower);

            // Glutes (Child of Upper Leg Groups - slightly better conceptually than torso)
            const gluteRadius = 0.2;
            const gluteGeo = new THREE.SphereGeometry(gluteRadius, 8, 6);
            gluteGeo.scale(1, 1, 0.8); // Flatten slightly
            const gluteL = createMusclePart(gluteGeo, 'glutes');
            gluteL.position.set(0, -0.05, -0.1); // Local to hip joint
            upperLegL.add(gluteL); // CHILD OF UPPER LEG
            const gluteR = createMusclePart(gluteGeo, 'glutes');
            gluteR.position.set(0, -0.05, -0.1); // Local to hip joint
            upperLegR.add(gluteR); // CHILD OF UPPER LEG

            // Quads (Child of Upper Leg Groups)
            const quadGeo = new THREE.CapsuleGeometry(0.12, 0.5, 4, 8);
            const quadL = createMusclePart(quadGeo, 'quads');
            quadL.position.set(0, -legLengthUpper*0.4, 0.1); // Local to hip joint, slightly forward
            quadL.rotation.x = Math.PI / 2; // Orient capsule
            upperLegL.add(quadL); // CHILD OF UPPER LEG
            const quadR = createMusclePart(quadGeo, 'quads');
            quadR.position.set(0, -legLengthUpper*0.4, 0.1); // Local to hip joint
            quadR.rotation.x = Math.PI / 2;
            upperLegR.add(quadR); // CHILD OF UPPER LEG

            // Hamstrings (Child of Upper Leg Groups)
            const hamGeo = new THREE.CapsuleGeometry(0.1, 0.45, 4, 8);
            const hamL = createMusclePart(hamGeo, 'hamstrings');
            hamL.position.set(0, -legLengthUpper*0.45, -0.12); // Local to hip joint, slightly back
            hamL.rotation.x = Math.PI / 2;
            upperLegL.add(hamL); // CHILD OF UPPER LEG
            const hamR = createMusclePart(hamGeo, 'hamstrings');
            hamR.position.set(0, -legLengthUpper*0.45, -0.12); // Local to hip joint
            hamR.rotation.x = Math.PI / 2;
            upperLegR.add(hamR); // CHILD OF UPPER LEG

            // Calves (Child of Lower Leg Groups) - THIS IS THE CRITICAL FIX
            const calfGeo = new THREE.CapsuleGeometry(0.09, 0.35, 4, 8);
            const calfL = createMusclePart(calfGeo, 'calves');
            calfL.position.set(0, -legLengthLower*0.4, -0.08); // Local to KNEE joint, slightly back
            calfL.rotation.x = Math.PI / 2; // Orient capsule
            lowerLegL.add(calfL); // CHILD OF LOWER LEG GROUP
            const calfR = createMusclePart(calfGeo, 'calves');
            calfR.position.set(0, -legLengthLower*0.4, -0.08); // Local to KNEE joint
            calfR.rotation.x = Math.PI / 2;
            lowerLegR.add(calfR); // CHILD OF LOWER LEG GROUP


            // Initialize states
            Object.keys(muscleMeshes).forEach(key => {
                muscleStates[key] = 'off';
            });
        }

        // --- UI Interaction ---
        function setupUI() {
            const labels = document.querySelectorAll('#controls label');
            labels.forEach(label => {
                const muscleName = label.dataset.muscle;
                if (muscleName) {
                    if (!muscleStates[muscleName]) {
                         muscleStates[muscleName] = 'off';
                    }
                    updateLabelAppearance(label, muscleStates[muscleName]);

                    label.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        handleMuscleClick(muscleName, label);
                    });
                }
            });

             // Add name attribute to ground plane for easier access
             scene.getObjectByName('groundPlane').name = 'groundPlane';
        }


        function handleMuscleClick(muscleName, labelElement) {
            const currentState = muscleStates[muscleName];
            let nextState;

            if (currentState === 'off') {
                nextState = 'selected';
            } else if (currentState === 'selected') {
                nextState = 'completed';
            } else { // completed
                nextState = 'off';
            }

            muscleStates[muscleName] = nextState;
            updateMuscleAppearance(muscleName);
            updateLabelAppearance(labelElement, nextState);
        }

        function updateMuscleAppearance(muscleName) {
            const meshes = muscleMeshes[muscleName];
            if (!meshes) return;

            const state = muscleStates[muscleName];
            let targetMaterial;
            let visible = true;

            switch (state) {
                case 'selected': targetMaterial = muscleMaterials.selected; break;
                case 'completed': targetMaterial = muscleMaterials.completed; break;
                case 'off': default: targetMaterial = muscleMaterials.off; visible = false; break;
            }

            meshes.forEach(mesh => {
                 if (mesh.material !== targetMaterial && state !== 'off') {
                     mesh.material = targetMaterial;
                 }
                 mesh.visible = visible;
            });
        }

         function updateLabelAppearance(labelElement, state) {
             const checkbox = labelElement.querySelector('input[type="checkbox"]');
             if (!checkbox) return;

             labelElement.classList.remove('state-off', 'state-selected', 'state-completed');

             switch (state) {
                case 'selected':
                    labelElement.classList.add('state-selected');
                    checkbox.checked = true;
                    checkbox.indeterminate = false;
                    break;
                case 'completed':
                    labelElement.classList.add('state-completed');
                    checkbox.checked = true;
                    checkbox.indeterminate = true; // Use indeterminate visually for 'completed'
                    break;
                case 'off':
                default:
                    labelElement.classList.add('state-off');
                    checkbox.checked = false;
                    checkbox.indeterminate = false;
                    break;
            }
         }

        // --- Window Resize ---
        function onWindowResize() {
            const container = document.getElementById('container');
            if (!container) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
             if (width === 0 || height === 0) return;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
