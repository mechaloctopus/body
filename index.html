<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Poly Muscle Highlighter</title>
    <style>
        body { margin: 0; font-family: sans-serif; background-color: #f0f0f0; display: flex; height: 100vh; overflow: hidden; }
        #container { flex-grow: 1; position: relative; }
        #canvas { display: block; }
        #controls {
            width: 280px; /* Slightly wider for better text */
            padding: 20px;
            background-color: #fff;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box; /* Include padding in height/width */
        }
        #controls h2 { margin-top: 0; }
        #controls label {
            display: block;
            margin-bottom: 10px;
            padding: 5px; /* Add padding for easier clicking */
            border-radius: 3px; /* Slightly rounded corners */
            cursor: pointer;
            user-select: none; /* Prevent text selection on double click */
            transition: background-color 0.2s ease; /* Smooth feedback */
        }
         #controls input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle; /* Align checkbox better */
            pointer-events: none; /* Prevent direct interaction with checkbox */
         }
         .state-off { color: #555; background-color: #f9f9f9; }
         .state-off:hover { background-color: #eee; }
         .state-selected { color: red; font-weight: bold; background-color: #ffe0e0; }
         .state-completed { color: purple; font-weight: bold; text-decoration: line-through; background-color: #f0e0f0; }

    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="controls">
        <h2>Muscle Groups</h2>
        <label data-muscle="pectorals">
            <input type="checkbox" id="cb-pectorals"> Pectorals (Chest)
        </label>
        <label data-muscle="deltoids">
            <input type="checkbox" id="cb-deltoids"> Deltoids (Shoulders)
        </label>
        <label data-muscle="biceps">
            <input type="checkbox" id="cb-biceps"> Biceps
        </label>
        <label data-muscle="triceps">
            <input type="checkbox" id="cb-triceps"> Triceps
        </label>
        <label data-muscle="forearms">
            <input type="checkbox" id="cb-forearms"> Forearms
        </label>
        <label data-muscle="abs">
            <input type="checkbox" id="cb-abs"> Abdominals (Abs)
        </label>
        <label data-muscle="obliques"> {/* Added Obliques */}
            <input type="checkbox" id="cb-obliques"> Obliques (Sides)
        </label>
        <label data-muscle="back_upper">
            <input type="checkbox" id="cb-back_upper"> Upper Back (Traps, Rhomboids)
        </label>
        <label data-muscle="back_lats">
            <input type="checkbox" id="cb-back_lats"> Lats (Mid Back)
        </label>
        <label data-muscle="back_lower">
            <input type="checkbox" id="cb-back_lower"> Lower Back (Erectors)
        </label>
        <label data-muscle="glutes">
            <input type="checkbox" id="cb-glutes"> Glutes
        </label>
        <label data-muscle="quads">
            <input type="checkbox" id="cb-quads"> Quadriceps (Quads)
        </label>
        <label data-muscle="hamstrings">
            <input type="checkbox" id="cb-hamstrings"> Hamstrings
        </label>
         <label data-muscle="calves">
            <input type="checkbox" id="cb-calves"> Calves
        </label>
        <hr>
        <p><strong>Instructions:</strong><br>
        - Click + Drag to rotate.<br>
        - Scroll to zoom.<br>
        - Click muscle names to cycle: Off -> Selected (Red) -> Completed (Purple) -> Off.
        </p>
    </div>

    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // Optional: For more complex shapes later if needed
        // import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        let scene, camera, renderer, controls;
        let humanGroup; // Group to hold all parts of the human
        const muscleMeshes = {}; // Store references to muscle meshes
        const muscleStates = {}; // Store state: 'off', 'selected', 'completed'

        const colors = {
            skin: 0xd3a18d, // A basic skin-like color
            muscleOff: 0xaaaaaa, // Default grey when not active (actually hidden now)
            muscleSelected: 0xff0000, // Red
            muscleCompleted: 0x800080, // Purple
            muscleOpacity: 0.85 // Slightly more opaque
        };

        // Re-use materials for performance
        const muscleMaterials = {
            off: new THREE.MeshStandardMaterial({ // Used internally, but meshes set invisible
                color: colors.muscleOff,
                transparent: true,
                opacity: 0, // Start fully transparent
                visible: false, // Start invisible
                roughness: 0.8,
                metalness: 0.1
            }),
            selected: new THREE.MeshStandardMaterial({
                color: colors.muscleSelected,
                transparent: true,
                opacity: colors.muscleOpacity,
                roughness: 0.6,
                metalness: 0.1,
                emissive: 0x330000 // Slight glow for red
            }),
            completed: new THREE.MeshStandardMaterial({
                color: colors.muscleCompleted,
                transparent: true,
                opacity: colors.muscleOpacity,
                roughness: 0.6,
                metalness: 0.1,
                emissive: 0x1a001a // Slight glow for purple
            })
        };

        // --- Initialization ---
        function init() {
            const container = document.getElementById('container');
            const canvas = document.getElementById('canvas');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee); // Lighter background

            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 6); // Adjusted initial camera

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows for depth

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6)); // Softer ambient
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // Stronger directional
            dirLight.position.set(8, 15, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0); // Target the center of the model
            controls.minDistance = 2; // Prevent zooming too close
            controls.maxDistance = 15; // Prevent zooming too far
            controls.update();

            // Ground Plane (optional, for shadow)
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 1, metalness: 0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.8; // Adjust based on model's lowest point
            ground.receiveShadow = true;
            scene.add(ground);

            // Build Model
            buildHumanModel();

            // Setup UI Listeners
            setupUI();

            // Handle Window Resize
            window.addEventListener('resize', onWindowResize);

            // Start Animation Loop
            animate();
        }

        // --- Build Model (REFINED) ---
        function buildHumanModel() {
            humanGroup = new THREE.Group();
            scene.add(humanGroup);

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: colors.skin,
                roughness: 0.8, // Slightly less rough
                metalness: 0.05
            });

             // Function to create body parts that cast shadows
            function createBodyPart(geometry, material, position, rotation = null) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                if (rotation) {
                    mesh.rotation.copy(rotation);
                }
                mesh.castShadow = true; // Body parts cast shadows
                humanGroup.add(mesh);
                return mesh;
            }
             // Function to create muscle parts
            function createMusclePart(geometry, muscleName, side = null) {
                 const mesh = new THREE.Mesh(geometry, muscleMaterials.off.clone()); // Start with 'off' material
                 mesh.visible = false; // Start invisible
                 // Muscles generally shouldn't cast shadows themselves to avoid visual noise
                 // mesh.castShadow = true;
                 humanGroup.add(mesh);

                 const key = muscleName;
                 if (!muscleMeshes[key]) {
                     muscleMeshes[key] = [];
                 }
                 muscleMeshes[key].push(mesh);
                 return mesh; // Return for positioning
            }

            const torsoHeight = 1.0;
            const torsoWidth = 0.7;
            const torsoDepth = 0.35;
            const shoulderWidth = 0.45; // Half width from center to shoulder joint
            const armLengthUpper = 0.6;
            const armLengthLower = 0.55;
            const legLengthUpper = 0.8;
            const legLengthLower = 0.7;
            const neckHeight = 0.15;
            const headRadius = 0.25;

            const legOffsetY = - (legLengthLower / 2 + legLengthUpper / 2 + 0.05); // Base Y position for legs


            // --- Base Body Parts (Refined Proportions & Pose) ---
            const torsoPos = new THREE.Vector3(0, legOffsetY + legLengthLower + legLengthUpper + torsoHeight / 2, 0);
            const torsoGeo = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth);
            createBodyPart(torsoGeo, bodyMaterial, torsoPos);

            const neckPos = new THREE.Vector3(0, torsoPos.y + torsoHeight / 2 + neckHeight / 2, 0);
            const neckGeo = new THREE.CylinderGeometry(0.1, 0.12, neckHeight, 8);
            createBodyPart(neckGeo, bodyMaterial, neckPos);

            const headPos = new THREE.Vector3(0, neckPos.y + neckHeight / 2 + headRadius, 0);
            const headGeo = new THREE.SphereGeometry(headRadius, 12, 8);
            createBodyPart(headGeo, bodyMaterial, headPos);

            // Arms (Slight A-Pose and elbow bend)
            const armAngleZ = Math.PI / 16; // Slight angle down
            const elbowAngleX = Math.PI / 12; // Slight bend forward

            // Left Arm
            const upperArmLPos = new THREE.Vector3(-shoulderWidth, torsoPos.y + torsoHeight/2 - 0.1, 0);
            const upperArmLGeo = new THREE.CylinderGeometry(0.1, 0.08, armLengthUpper, 8);
            const upperArmL = createBodyPart(upperArmLGeo, bodyMaterial, upperArmLPos);
            upperArmL.geometry.translate(0, -armLengthUpper/2, 0); // Pivot from shoulder
            upperArmL.rotation.z = armAngleZ;

            const lowerArmLPos = new THREE.Vector3().setFromCylindricalCoords(armLengthUpper, Math.PI/2 - armAngleZ, 0).add(upperArmLPos); // Position at end of upper arm
            const lowerArmLGeo = new THREE.CylinderGeometry(0.08, 0.06, armLengthLower, 8);
            const lowerArmL = createBodyPart(lowerArmLGeo, bodyMaterial, lowerArmLPos);
            lowerArmL.geometry.translate(0, -armLengthLower/2, 0); // Pivot from elbow
            lowerArmL.rotation.z = armAngleZ;
            lowerArmL.rotation.x = elbowAngleX; // Add elbow bend


            // Right Arm
            const upperArmRPos = new THREE.Vector3(shoulderWidth, torsoPos.y + torsoHeight/2 - 0.1, 0);
            const upperArmRGeo = new THREE.CylinderGeometry(0.1, 0.08, armLengthUpper, 8);
            const upperArmR = createBodyPart(upperArmRGeo, bodyMaterial, upperArmRPos);
            upperArmR.geometry.translate(0, -armLengthUpper/2, 0);
            upperArmR.rotation.z = -armAngleZ;

            const lowerArmRPos = new THREE.Vector3().setFromCylindricalCoords(armLengthUpper, Math.PI/2 + armAngleZ, 0).add(upperArmRPos);
            const lowerArmRGeo = new THREE.CylinderGeometry(0.08, 0.06, armLengthLower, 8);
            const lowerArmR = createBodyPart(lowerArmRGeo, bodyMaterial, lowerArmRPos);
            lowerArmR.geometry.translate(0, -armLengthLower/2, 0);
            lowerArmR.rotation.z = -armAngleZ;
            lowerArmR.rotation.x = elbowAngleX;


            // Legs (Slight knee bend)
            const hipWidth = 0.2;
            const kneeAngleX = -Math.PI / 18; // Slight bend backward

            // Left Leg
            const upperLegLPos = new THREE.Vector3(-hipWidth, legOffsetY + legLengthLower + legLengthUpper, 0);
            const upperLegLGeo = new THREE.CylinderGeometry(0.15, 0.12, legLengthUpper, 8);
            const upperLegL = createBodyPart(upperLegLGeo, bodyMaterial, upperLegLPos);
            upperLegL.geometry.translate(0, -legLengthUpper/2, 0); // Pivot from hip

            const lowerLegLPos = new THREE.Vector3().setFromCylindricalCoords(legLengthUpper, -Math.PI/2, 0).add(upperLegLPos);
            const lowerLegLGeo = new THREE.CylinderGeometry(0.12, 0.08, legLengthLower, 8);
            const lowerLegL = createBodyPart(lowerLegLGeo, bodyMaterial, lowerLegLPos);
            lowerLegL.geometry.translate(0, -legLengthLower/2, 0); // Pivot from knee
            lowerLegL.rotation.x = kneeAngleX; // Add knee bend

            // Right Leg
            const upperLegRPos = new THREE.Vector3(hipWidth, legOffsetY + legLengthLower + legLengthUpper, 0);
            const upperLegRGeo = new THREE.CylinderGeometry(0.15, 0.12, legLengthUpper, 8);
            const upperLegR = createBodyPart(upperLegRGeo, bodyMaterial, upperLegRPos);
            upperLegR.geometry.translate(0, -legLengthUpper/2, 0);

            const lowerLegRPos = new THREE.Vector3().setFromCylindricalCoords(legLengthUpper, -Math.PI/2, 0).add(upperLegRPos);
            const lowerLegRGeo = new THREE.CylinderGeometry(0.12, 0.08, legLengthLower, 8);
            const lowerLegR = createBodyPart(lowerLegRGeo, bodyMaterial, lowerLegRPos);
            lowerLegR.geometry.translate(0, -legLengthLower/2, 0);
            lowerLegR.rotation.x = kneeAngleX;


            // --- Muscle Groups (Refined Shapes & Placement) ---
            const muscleOffset = 0.01; // Minimal offset

            // Pectorals (Slightly shaped)
            const pecWidth = 0.3; const pecHeight = 0.3; const pecDepth = 0.08;
            const pecGeo = new THREE.BoxGeometry(pecWidth, pecHeight, pecDepth);
            const pecL = createMusclePart(pecGeo, 'pectorals');
            pecL.position.set(-pecWidth/2 - 0.02, torsoPos.y + 0.1, torsoDepth / 2 + muscleOffset);
            pecL.rotation.y = -Math.PI / 20; // Slight angle
            const pecR = createMusclePart(pecGeo, 'pectorals');
            pecR.position.set( pecWidth/2 + 0.02, torsoPos.y + 0.1, torsoDepth / 2 + muscleOffset);
            pecR.rotation.y = Math.PI / 20; // Slight angle

            // Deltoids (More like caps)
            const deltRadius = 0.18;
            const deltGeo = new THREE.SphereGeometry(deltRadius, 8, 6, 0, Math.PI * 2, 0, Math.PI / 1.8); // Hemisphere cap
            const deltL = createMusclePart(deltGeo, 'deltoids');
            deltL.position.copy(upperArmLPos).add(new THREE.Vector3(0, 0.05, 0)); // Position at shoulder joint
            deltL.rotation.z = Math.PI / 6; // Angle with arm
            const deltR = createMusclePart(deltGeo.clone().rotateY(Math.PI), 'deltoids'); // Clone and flip geometry
            deltR.position.copy(upperArmRPos).add(new THREE.Vector3(0, 0.05, 0));
            deltR.rotation.z = -Math.PI / 6;

            // Biceps (Positioned on upper arm)
            const bicepGeo = new THREE.CapsuleGeometry(0.06, 0.2, 4, 8); // Capsule shape
            const bicepL = createMusclePart(bicepGeo, 'biceps');
            bicepL.position.set(upperArmLPos.x, upperArmLPos.y - armLengthUpper*0.4, upperArmLPos.z + 0.05); // Place along upper arm
            bicepL.rotation.z = armAngleZ; // Match arm angle
            bicepL.rotation.x = Math.PI / 2; // Orient capsule along arm
            const bicepR = createMusclePart(bicepGeo, 'biceps');
            bicepR.position.set(upperArmRPos.x, upperArmRPos.y - armLengthUpper*0.4, upperArmRPos.z + 0.05);
            bicepR.rotation.z = -armAngleZ;
            bicepR.rotation.x = Math.PI / 2;

            // Triceps (Positioned on back of upper arm)
            const tricepGeo = new THREE.CapsuleGeometry(0.07, 0.25, 4, 8); // Slightly larger capsule
            const tricepL = createMusclePart(tricepGeo, 'triceps');
            tricepL.position.set(upperArmLPos.x, upperArmLPos.y - armLengthUpper*0.45, upperArmLPos.z - 0.05); // Place behind arm
            tricepL.rotation.z = armAngleZ;
            tricepL.rotation.x = Math.PI / 2;
            const tricepR = createMusclePart(tricepGeo, 'triceps');
            tricepR.position.set(upperArmRPos.x, upperArmRPos.y - armLengthUpper*0.45, upperArmRPos.z - 0.05);
            tricepR.rotation.z = -armAngleZ;
            tricepR.rotation.x = Math.PI / 2;

            // Forearms (Bulge on lower arm)
            const forearmGeo = new THREE.CapsuleGeometry(0.07, 0.3, 4, 8);
            const forearmL = createMusclePart(forearmGeo, 'forearms');
            // Position relative to lower arm's local space, then apply world rotation
            const forearmLocalPosL = new THREE.Vector3(0, -armLengthLower*0.3, 0.02); // Along the arm, slightly top/front
            forearmL.position.copy(forearmLocalPosL).applyEuler(lowerArmL.rotation).add(lowerArmL.position);
            forearmL.rotation.copy(lowerArmL.rotation); // Align with lower arm
            forearmL.rotateX(Math.PI / 2); // Orient capsule along arm length

            const forearmR = createMusclePart(forearmGeo, 'forearms');
            const forearmLocalPosR = new THREE.Vector3(0, -armLengthLower*0.3, 0.02);
            forearmR.position.copy(forearmLocalPosR).applyEuler(lowerArmR.rotation).add(lowerArmR.position);
            forearmR.rotation.copy(lowerArmR.rotation);
            forearmR.rotateX(Math.PI / 2);

            // Abdominals (Single panel, slightly curved) - Could use RoundedBox if desired
            const absWidth = 0.35; const absHeight = 0.45; const absDepth = 0.08;
            const absGeo = new THREE.BoxGeometry(absWidth, absHeight, absDepth);
            const abs = createMusclePart(absGeo, 'abs');
            abs.position.set(0, torsoPos.y - 0.1, torsoDepth / 2 + muscleOffset);
            // abs.rotation.x = Math.PI / 20; // Slight curve back

            // Obliques (Side panels) - NEW
            const obqWidth = 0.1; const obqHeight = 0.4; const obqDepth = 0.25;
            const obqGeo = new THREE.BoxGeometry(obqWidth, obqHeight, obqDepth);
            const obqL = createMusclePart(obqGeo, 'obliques');
            obqL.position.set(-(torsoWidth/2 + obqWidth/2 - 0.05), torsoPos.y - 0.1, 0);
             obqL.rotation.y = Math.PI/10; // Angle slightly
            const obqR = createMusclePart(obqGeo, 'obliques');
            obqR.position.set( (torsoWidth/2 + obqWidth/2 - 0.05), torsoPos.y - 0.1, 0);
            obqR.rotation.y = -Math.PI/10; // Angle slightly


            // Back - Upper (Traps - more diamond like)
            const trapWidth = 0.4; const trapHeight = 0.4; const trapDepth = 0.1;
            const trapGeo = new THREE.BoxGeometry(trapWidth, trapHeight, trapDepth); // Simple box for now
            const backUpper = createMusclePart(trapGeo, 'back_upper');
            backUpper.position.set(0, torsoPos.y + torsoHeight/2 - trapHeight/2 + 0.1, -torsoDepth / 2 - muscleOffset);
            // Consider using a ShapeGeometry for a better trap shape later

            // Back - Lats (Wider, wing-like)
            const latWidth = 0.25; const latHeight = 0.5; const latDepth = 0.1;
            const latGeo = new THREE.BoxGeometry(latWidth, latHeight, latDepth);
            const latL = createMusclePart(latGeo, 'back_lats');
            latL.position.set(-(torsoWidth/2 - latWidth/2 + 0.05), torsoPos.y - 0.1, -torsoDepth / 2 - muscleOffset * 2);
            latL.rotation.y = Math.PI/6; // Angle out slightly
            const latR = createMusclePart(latGeo, 'back_lats');
            latR.position.set( (torsoWidth/2 - latWidth/2 + 0.05), torsoPos.y - 0.1, -torsoDepth / 2 - muscleOffset * 2);
             latR.rotation.y = -Math.PI/6; // Angle out slightly

            // Back - Lower (Erectors)
            const lowBackWidth = 0.2; const lowBackHeight = 0.3; const lowBackDepth = 0.08;
            const backLowerGeo = new THREE.BoxGeometry(lowBackWidth, lowBackHeight, lowBackDepth);
            const backLower = createMusclePart(backLowerGeo, 'back_lower');
            backLower.position.set(0, torsoPos.y - torsoHeight/2 + lowBackHeight/2, -torsoDepth / 2 - muscleOffset);

            // Glutes (Rounded)
            const gluteRadius = 0.2;
            const gluteGeo = new THREE.SphereGeometry(gluteRadius, 8, 6); // Use spheres
            gluteGeo.scale(1, 1, 0.8); // Flatten slightly
            const gluteL = createMusclePart(gluteGeo, 'glutes');
            gluteL.position.set(-hipWidth, upperLegLPos.y - 0.05, -0.1); // Position relative to hip/leg top
            const gluteR = createMusclePart(gluteGeo, 'glutes');
            gluteR.position.set( hipWidth, upperLegRPos.y - 0.05, -0.1);

            // Quads (Front of thigh)
            const quadGeo = new THREE.CapsuleGeometry(0.12, 0.5, 4, 8);
            const quadL = createMusclePart(quadGeo, 'quads');
            quadL.position.set(upperLegLPos.x, upperLegLPos.y - legLengthUpper*0.4, upperLegLPos.z + 0.08); // Place along upper leg
            quadL.rotation.x = Math.PI / 2; // Orient capsule
            const quadR = createMusclePart(quadGeo, 'quads');
            quadR.position.set(upperLegRPos.x, upperLegRPos.y - legLengthUpper*0.4, upperLegRPos.z + 0.08);
            quadR.rotation.x = Math.PI / 2;

            // Hamstrings (Back of thigh)
            const hamGeo = new THREE.CapsuleGeometry(0.1, 0.45, 4, 8);
            const hamL = createMusclePart(hamGeo, 'hamstrings');
            hamL.position.set(upperLegLPos.x, upperLegLPos.y - legLengthUpper*0.45, upperLegLPos.z - 0.08); // Place behind leg
            hamL.rotation.x = Math.PI / 2;
            const hamR = createMusclePart(hamGeo, 'hamstrings');
            hamR.position.set(upperLegRPos.x, upperLegRPos.y - legLengthUpper*0.45, upperLegRPos.z - 0.08);
            hamR.rotation.x = Math.PI / 2;

            // Calves (Back of lower leg)
            const calfGeo = new THREE.CapsuleGeometry(0.09, 0.35, 4, 8);
            const calfL = createMusclePart(calfGeo, 'calves');
            // Position relative to lower leg's local space
            const calfLocalPosL = new THREE.Vector3(0, -legLengthLower*0.4, -0.06); // Along the leg, back side
            calfL.position.copy(calfLocalPosL).applyEuler(lowerLegL.rotation).add(lowerLegL.position);
            calfL.rotation.copy(lowerLegL.rotation); // Align with lower leg
            calfL.rotateX(Math.PI / 2); // Orient capsule along leg length

            const calfR = createMusclePart(calfGeo, 'calves');
            const calfLocalPosR = new THREE.Vector3(0, -legLengthLower*0.4, -0.06);
            calfR.position.copy(calfLocalPosR).applyEuler(lowerLegR.rotation).add(lowerLegR.position);
            calfR.rotation.copy(lowerLegR.rotation);
            calfR.rotateX(Math.PI / 2);


            // Initialize all muscle states to 'off'
            Object.keys(muscleMeshes).forEach(key => {
                muscleStates[key] = 'off';
                // Appearance is handled by visibility flag now
            });
        }

        // --- UI Interaction ---
        function setupUI() {
            const labels = document.querySelectorAll('#controls label');
            labels.forEach(label => {
                const muscleName = label.dataset.muscle;
                if (muscleName) {
                    // Ensure initial state matches muscleStates (all 'off')
                    if (!muscleStates[muscleName]) {
                         muscleStates[muscleName] = 'off';
                    }
                    updateLabelAppearance(label, muscleStates[muscleName]); // Set initial class/check state

                    label.addEventListener('click', (event) => {
                        // We manage state, prevent default label behavior (like checkbox toggle)
                        event.preventDefault();
                        event.stopPropagation(); // Prevent potential bubbling issues
                        handleMuscleClick(muscleName, label);
                    });
                }
            });
        }


        function handleMuscleClick(muscleName, labelElement) {
            const currentState = muscleStates[muscleName];
            let nextState;

            if (currentState === 'off') {
                nextState = 'selected';
            } else if (currentState === 'selected') {
                nextState = 'completed';
            } else { // completed
                nextState = 'off';
            }

            muscleStates[muscleName] = nextState;
            updateMuscleAppearance(muscleName);
            updateLabelAppearance(labelElement, nextState);
        }

        function updateMuscleAppearance(muscleName) {
            const meshes = muscleMeshes[muscleName];
            if (!meshes) return;

            const state = muscleStates[muscleName];
            let targetMaterial;
            let visible = true;

            switch (state) {
                case 'selected':
                    targetMaterial = muscleMaterials.selected;
                    break;
                case 'completed':
                    targetMaterial = muscleMaterials.completed;
                    break;
                case 'off':
                default:
                    // Keep material reference but make invisible
                    targetMaterial = muscleMaterials.off; // Doesn't really matter which one if invisible
                    visible = false;
                    break;
            }

            meshes.forEach(mesh => {
                // Only update material if it needs changing (slight optimization)
                if (mesh.material !== targetMaterial && state !== 'off') {
                     mesh.material = targetMaterial;
                }
                 mesh.visible = visible;
            });
        }

         function updateLabelAppearance(labelElement, state) {
             const checkbox = labelElement.querySelector('input[type="checkbox"]');
             if (!checkbox) return; // Guard against missing checkbox

             // Remove existing state classes
             labelElement.classList.remove('state-off', 'state-selected', 'state-completed');

             switch (state) {
                case 'selected':
                    labelElement.classList.add('state-selected');
                    checkbox.checked = true;
                    checkbox.indeterminate = false;
                    break;
                case 'completed':
                    labelElement.classList.add('state-completed');
                    checkbox.checked = true; // Visually checked
                    checkbox.indeterminate = true; // Use indeterminate visually for 'completed' state
                    break;
                case 'off':
                default:
                    labelElement.classList.add('state-off');
                    checkbox.checked = false;
                    checkbox.indeterminate = false;
                    break;
            }
         }

        // --- Window Resize ---
        function onWindowResize() {
            const container = document.getElementById('container');
            if (!container) return; // Check if container exists
            const width = container.clientWidth;
            const height = container.clientHeight;

             if (width === 0 || height === 0) return; // Avoid issues if container is hidden

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Required for damping
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
